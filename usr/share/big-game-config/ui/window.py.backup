"""
Main application window with sidebar navigation and adaptive views.
"""

import gi
import os

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")

from gi.repository import Gtk, Adw, GLib, Gio
from core.packages import get_packages_by_category
from ui.install_dialog import InstallDialog
from utils.i18n import _


class BigGameConfigWindow(Adw.ApplicationWindow):
    """Main application window with sidebar navigation."""

    def __init__(self, *args, **kwargs):
        # Debug log
        import sys
        self.debug_log = open("/tmp/big-game-config-debug.log", "w")
        def log(msg):
            self.debug_log.write(msg + "\n")
            self.debug_log.flush()

        log("=== BigGameConfigWindow.__init__ called ===")
        super().__init__(*args, **kwargs)
        log("  Super init done")

        # Determine base directory for resources
        self.base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if self.base_dir == "/usr/share":
            self.base_dir = "/usr/share/big-game-config"
        log(f"  Base dir: {self.base_dir}")

        # Configure window
        self.set_title(_("BigLinux Game Config"))
        self.set_default_size(1100, 700)
        log("  Window configured")

        # Current view
        self.current_view = "home"

        # Build UI
        log("  Building UI...")
        self._build_ui(log)
        log("=== Window init complete ===")
        self.debug_log.close()

    def _build_ui(self, log=None):
        """Build the main window UI with sidebar navigation."""
        if not log:
            log = lambda x: None

        log("    _build_ui: Creating toolbar view...")
        # Toolbar view for header and content
        toolbar_view = Adw.ToolbarView()

        # Header bar with search
        header = Adw.HeaderBar()
        log("    _build_ui: Header bar created")

        # Search entry
        self.search_entry = Gtk.SearchEntry()
        self.search_entry.set_placeholder_text(_("Search packages..."))
        self.search_entry.set_hexpand(True)
        self.search_entry.set_max_width_chars(50)
        self.search_entry.connect("search-changed", self._on_search_changed)
        header.set_title_widget(self.search_entry)

        # Menu button
        menu_button = Gtk.MenuButton()
        menu_button.set_icon_name("open-menu-symbolic")
        menu = Gio.Menu()
        menu.append(_("About"), "app.about")
        menu.append(_("Quit"), "app.quit")
        menu_button.set_menu_model(menu)
        header.pack_end(menu_button)

        toolbar_view.add_top_bar(header)

        # Navigation split view (sidebar + content)
        self.split_view = Adw.NavigationSplitView()
        self.split_view.set_show_content(True)

        # Sidebar
        sidebar = self._create_sidebar()
        self.split_view.set_sidebar(sidebar)

        # Content area with view stack
        self.view_stack = Gtk.Stack()
        self.view_stack.set_transition_type(Gtk.StackTransitionType.CROSSFADE)
        self.view_stack.set_transition_duration(200)

        # Create all views
        log("    Creating views...")
        self._create_home_view()
        log("      ✓ Home view created")
        self._create_launchers_view()
        log("      ✓ Launchers view created")
        self._create_emulators_view()
        log("      ✓ Emulators view created")
        self._create_tools_view()
        log("      ✓ Tools view created")
        self._create_hardware_view()
        log("      ✓ Hardware view created")

        # Debug: List all views in stack with their names
        log("    Views in stack:")
        test_names = ["home", "launchers", "emulators", "tools", "hardware"]
        for name in test_names:
            child = self.view_stack.get_child_by_name(name)
            if child:
                log(f"      ✓ '{name}' -> {child}")
            else:
                log(f"      ✗ '{name}' NOT FOUND!")

        # Also list all children
        log("    All children in stack:")
        child = self.view_stack.get_first_child()
        count = 0
        while child:
            log(f"      {count}: {child}")
            child = child.get_next_sibling()
            count += 1
        log(f"    Total views: {count}")

        # Wrap stack in scrolled window
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled.set_child(self.view_stack)

        # Navigation page for content
        content_page = Adw.NavigationPage()
        content_page.set_title(_("BigLinux Game Config"))
        content_page.set_child(scrolled)
        self.split_view.set_content(content_page)

        toolbar_view.set_content(self.split_view)
        self.set_content(toolbar_view)

    def _create_sidebar(self):
        """Create the sidebar with navigation items."""
        sidebar_page = Adw.NavigationPage()
        sidebar_page.set_title(_("Navigation"))

        sidebar_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)

        # List box for navigation
        list_box = Gtk.ListBox()
        list_box.set_selection_mode(Gtk.SelectionMode.SINGLE)
        list_box.add_css_class("navigation-sidebar")
        list_box.connect("row-activated", self._on_sidebar_row_activated)

        # Navigation items
        nav_items = [
            ("home", _("Home"), "user-home-symbolic"),
            ("launchers", _("Launchers"), "applications-games-symbolic"),
            ("emulators", _("Emulators"), "input-gaming-symbolic"),
            ("tools", _("Tools"), "applications-system-symbolic"),
            ("hardware", _("Hardware"), "computer-symbolic"),
        ]

        for view_id, label, icon_name in nav_items:
            row = Adw.ActionRow()
            row.set_title(label)

            icon = Gtk.Image.new_from_icon_name(icon_name)
            icon.set_pixel_size(20)
            row.add_prefix(icon)

            # Store view_id in row for later
            row.view_id = view_id

            # Also store in the parent ListBoxRow that will be created
            # We'll access it via get_child() in the activation handler
            list_box.append(row)

        # Select first item by default
        list_box.select_row(list_box.get_row_at_index(0))

        sidebar_box.append(list_box)
        sidebar_page.set_child(sidebar_box)

        return sidebar_page

    def _on_sidebar_row_activated(self, list_box, row):
        """Handle sidebar navigation."""
        # Get the AdwActionRow child from the ListBoxRow wrapper
        action_row = row.get_child()
        view_id = getattr(action_row, 'view_id', None)

        if not view_id:
            print(f"Warning: Row child has no view_id attribute")
            print(f"  Row type: {type(row)}")
            print(f"  Child type: {type(action_row)}")
            return

        print(f"Navigating to: {view_id}")
        self.current_view = view_id
        self.view_stack.set_visible_child_name(view_id)

        # Clear search when changing views
        self.search_entry.set_text("")

    def _create_home_view(self):
        """Create home/overview view."""
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=24)
        box.set_margin_top(40)
        box.set_margin_bottom(40)
        box.set_margin_start(40)
        box.set_margin_end(40)

        # Welcome message
        status_page = Adw.StatusPage()
        status_page.set_icon_name("applications-games-symbolic")
        status_page.set_title(_("BigLinux Game Config"))
        status_page.set_description(_("Install and manage your gaming applications and tools.\nSelect a category from the sidebar to get started."))

        box.append(status_page)

        self.view_stack.add_named(box, "home")

    def _create_launchers_view(self):
        """Create launchers view with large cards (2x2 grid)."""
        print("\n_create_launchers_view called")
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        box.set_margin_top(30)
        box.set_margin_bottom(30)
        box.set_margin_start(40)
        box.set_margin_end(40)

        # Title
        title = Gtk.Label()
        title.set_markup(f"<span size='xx-large' weight='bold'>{_('Launchers')}</span>")
        title.set_halign(Gtk.Align.START)
        box.append(title)

        # Grid for cards
        grid = Gtk.Grid()
        grid.set_row_spacing(20)
        grid.set_column_spacing(20)
        grid.set_column_homogeneous(True)

        # Get launcher packages
        packages_by_category = get_packages_by_category()
        print(f"  Found {len(packages_by_category)} categories")
        launchers = None
        for cat_key, packages in packages_by_category.items():
            print(f"    Checking category: {cat_key[1]}")
            if "Launcher" in cat_key[1]:
                launchers = packages
                print(f"      MATCH! Found {len(launchers)} launcher packages")
                break

        if launchers:
            print(f"  Creating {len(launchers)} cards...")
            row, col = 0, 0
            for package in launchers:
                print(f"    Card: {package['name']}")
                card = self._create_large_card(package)
                grid.attach(card, col, row, 1, 1)
                col += 1
                if col >= 2:  # 2 columns
                    col = 0
                    row += 1
        else:
            print("  ERROR: No launchers found!")

        box.append(grid)
        print(f"  Adding to stack with name 'launchers'")
        self.view_stack.add_named(box, "launchers")

    def _create_large_card(self, package):
        """Create a large card for launchers with circular icon."""
        card = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        card.add_css_class("card")
        card.set_size_request(300, 320)
        card.set_valign(Gtk.Align.START)

        # Icon container with circular background
        icon_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        icon_box.set_valign(Gtk.Align.CENTER)
        icon_box.set_margin_top(30)

        # Load icon
        icon_path = os.path.join(self.base_dir, "icons", f"{package['icon']}.svg")
        if os.path.exists(icon_path):
            try:
                from gi.repository import GdkPixbuf, Gdk
                pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(icon_path, 160, 160, True)
                texture = Gdk.Texture.new_for_pixbuf(pixbuf)
                icon = Gtk.Image.new_from_paintable(texture)
                icon.set_pixel_size(80)
                icon_box.append(icon)
            except Exception as e:
                print(f"Error loading icon: {e}")

        card.append(icon_box)

        # Name
        name_label = Gtk.Label()
        name_label.set_markup(f"<span size='x-large' weight='bold'>{package['name']}</span>")
        name_label.set_wrap(True)
        name_label.set_justify(Gtk.Justification.CENTER)
        card.append(name_label)

        # Description
        desc_label = Gtk.Label(label=package['description'])
        desc_label.set_wrap(True)
        desc_label.set_justify(Gtk.Justification.CENTER)
        desc_label.set_max_width_chars(35)
        desc_label.add_css_class("dim-label")
        desc_label.set_margin_start(20)
        desc_label.set_margin_end(20)
        card.append(desc_label)

        # Spacer
        spacer = Gtk.Box()
        spacer.set_vexpand(True)
        card.append(spacer)

        # Install button
        from core.pacman import is_package_installed
        is_installed = is_package_installed(package['package_name'])

        button = Gtk.Button(label=_("Remove") if is_installed else _("Install"))
        if is_installed:
            button.add_css_class("destructive-action")
        else:
            button.add_css_class("suggested-action")

        button.set_halign(Gtk.Align.CENTER)
        button.set_size_request(140, -1)
        button.set_margin_bottom(20)
        button.connect("clicked", self._on_install_clicked, package['package_name'])
        card.append(button)

        return card

    def _create_emulators_view(self):
        """Create emulators view with action rows."""
        self._create_list_view("emulators", _("Emulators"), "Emulator")

    def _create_tools_view(self):
        """Create tools view with action rows."""
        self._create_list_view("tools", _("Tools"), "Performance")

    def _create_hardware_view(self):
        """Create hardware view with action rows."""
        self._create_list_view("hardware", _("Hardware"), "Hardware")

    def _create_list_view(self, view_id, title, category_filter):
        """Create a list view with AdwActionRow for compact display."""
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        box.set_margin_top(30)
        box.set_margin_bottom(30)
        box.set_margin_start(40)
        box.set_margin_end(40)

        # Title
        title_label = Gtk.Label()
        title_label.set_markup(f"<span size='xx-large' weight='bold'>{title}</span>")
        title_label.set_halign(Gtk.Align.START)
        box.append(title_label)

        # Get packages for this category
        packages_by_category = get_packages_by_category()

        for cat_key, packages in packages_by_category.items():
            if category_filter in cat_key[1]:
                # Category group
                group = Adw.PreferencesGroup()
                group.set_title(cat_key[1])
                group.set_margin_top(10)

                for package in packages:
                    row = self._create_action_row(package)
                    group.add(row)

                box.append(group)

        self.view_stack.add_named(box, view_id)

    def _create_action_row(self, package):
        """Create an AdwActionRow for list view."""
        from core.pacman import is_package_installed

        row = Adw.ActionRow()
        row.set_title(package['name'])
        row.set_subtitle(package['description'])

        # Icon
        icon_path = os.path.join(self.base_dir, "icons", f"{package['icon']}.svg")
        if os.path.exists(icon_path):
            try:
                from gi.repository import GdkPixbuf, Gdk
                pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(icon_path, 96, 96, True)
                texture = Gdk.Texture.new_for_pixbuf(pixbuf)
                icon = Gtk.Image.new_from_paintable(texture)
                icon.set_pixel_size(48)
                row.add_prefix(icon)
            except Exception as e:
                print(f"Error loading icon: {e}")

        # Install button
        is_installed = is_package_installed(package['package_name'])
        button = Gtk.Button(label=_("Remove") if is_installed else _("Install"))

        if is_installed:
            button.add_css_class("destructive-action")
        else:
            button.add_css_class("suggested-action")

        button.set_valign(Gtk.Align.CENTER)
        button.set_size_request(100, -1)
        button.connect("clicked", self._on_install_clicked, package['package_name'])
        row.add_suffix(button)

        # Store button reference for refresh
        row.install_button = button
        row.package_name = package['package_name']

        return row

    def _on_install_clicked(self, button, package_name):
        """Handle install/remove button click."""
        from core.pacman import is_package_installed

        is_installed = is_package_installed(package_name)
        operation = "remove" if is_installed else "install"

        # Show install dialog
        dialog = InstallDialog(self, package_name, operation)
        dialog.present()

        # Refresh UI after dialog closes
        dialog.connect("close-request", lambda d: self._refresh_current_view())

    def _refresh_current_view(self):
        """Refresh the current view to update install/remove buttons."""
        # Simple approach: reload the current view
        GLib.timeout_add(500, self._do_refresh)

    def _do_refresh(self):
        """Actually perform the refresh."""
        # Force rebuild of current view
        current = self.current_view

        # Remove and recreate
        old_child = self.view_stack.get_child_by_name(current)
        if old_child:
            self.view_stack.remove(old_child)

        # Recreate view
        if current == "launchers":
            self._create_launchers_view()
        elif current == "emulators":
            self._create_emulators_view()
        elif current == "tools":
            self._create_tools_view()
        elif current == "hardware":
            self._create_hardware_view()

        # Show it again
        self.view_stack.set_visible_child_name(current)

        return False

    def _on_search_changed(self, search_entry):
        """Handle search text changes."""
        # TODO: Implement search functionality
        pass
